<!-- AGENT_SKIP_START: This section is for human readers only. Planning agents should skip to the next section. -->
<details>
<summary>DISCLAIMER: This repository is an active experiment in autonomous software engineering.</summary>


> **Current Status:** üöß **Alpha / Self-Driving**

This codebase is primarily managed and developed by a fleet of AI agents running on **Google's Jules** platform. It is **not** currently intended for production use.

### How It Works
The system uses a **Black Hole Architecture**‚Äîa planning-execution cycle designed to simulate a fully autonomous engineering team where agents continuously pull the codebase toward the documented vision:

1.  **Autonomous Scheduling:** "Prompts" are executed daily to drive the development lifecycle.
    * **Morning Phase:** Planning agents scan the codebase and `README` vision, identifying missing features or bugs to populate their own backlog.
    * **Afternoon Phase:** Execution agents implement the planned tasks.
    * **End-of-Day Phase:** Scribe agent consolidates progress logs and regenerates the context knowledge base for the next day's planning cycle.
2.  **Feedback Loops:** Agents are empowered to run their own validation using:
    * **Playwright** for End-to-End (E2E) testing.
    * **Visual Regression** via screenshot analysis.
    * **Unit Tests** (Vitest) for logic verification.
    * **Ad-hoc Bash Commands** for environment diagnostics.
3.  **Human-in-the-Loop:** While I act as the "Lead Architect" providing the high-level vision, my involvement is primarily limited to glancing at and merging Pull Requests generated by **Jules** and reviewed by a separate **GitHub Copilot** agent.

### Agent Prompts

For transparency and educational purposes, the complete prompts used to orchestrate the agent swarm are available in the [`docs/prompts/`](./docs/prompts/) directory.

**Expect rapid changes, experimental commits, and occasional "hallucinated" refactors as the swarm learns to optimize its own workflow.**
</details>
<!-- AGENT_SKIP_END -->

# Helios Engine

Helios is a modern, framework-agnostic engine for programmatic video creation.

Create high-quality videos using the web technologies you already know‚ÄîHTML, CSS, and JavaScript. No new paradigms to learn. Use your existing CSS animations, your favorite framework (or none), and prototype fast.

Helios prioritizes **developer experience** and **rapid prototyping** alongside performance, leveraging native browser APIs to deliver a next-generation video creation toolkit for the web.
**Table of Contents**
- [Core Principles](#core-principles)
- [Helios vs Remotion](#helios-vs-remotion)
- [Architectural Deep Dive](#architectural-deep-dive)
- [Technology Stack](#technology-stack)
- [Project Status](#project-status)
- [Roadmap](#roadmap-the-future-of-helios)
- [License](#license)
## Core Principles
The development of Helios is guided by a set of foundational principles that inform every architectural decision.

 - **Developer Experience First**: Getting started should take minutes, not hours. We prioritize intuitive APIs, minimal boilerplate, and instant feedback loops. If you know HTML, CSS, and JavaScript, you already know how to use Helios.
 - **Prototype Fast, Scale Later**: Helios is designed for rapid iteration. Start with a simple composition, preview instantly in your browser, and only worry about rendering infrastructure when you're ready to ship.
 - **Use What You Know**: The core logic is pure TypeScript with zero framework dependencies. Use React, Vue, Svelte, or vanilla JS‚Äîwhatever you're already comfortable with. No new paradigms to learn.
 - **Leverage Web Standards**: We prefer native browser APIs over custom implementations. CSS animations, Web Animations API, and standard DOM APIs you already know. Your existing web development skills transfer directly.
 - **Performance When It Matters**: Hardware-accelerated rendering, in-memory data piping, and WebCodecs support for canvas-heavy work. Performance is there when you need it, but never at the cost of developer ergonomics.
## Architectural Deep Dive
Helios is designed with a modular and flexible architecture that separates logic from presentation, providing developers with maximum power and control.
### 1. The Composition Layer: The Authoring Experience
This layer defines how developers create and describe their video content. Our approach is inspired by modern "Headless UI" libraries (like Radix UI or Headless UI) to provide a truly framework-agnostic core.

#### The "Headless" Logic Engine
The core of the library is an instantiable JavaScript class that acts as a "headless video engine." It manages all state (e.g., `currentFrame`, `duration`, `isPlaying`, `inputProps`), exposes methods (`play`, `pause`, `seek`), and provides a subscription mechanism for state changes. This decouples the core logic from any UI framework and allows multiple compositions to coexist safely on the same page.

#### Composition via Headless Adapters
To provide an idiomatic authoring experience, we will offer small, dedicated NPM packages that serve as lightweight adapters for popular frameworks. These adapters consume the core headless engine and expose its state in a way that feels native to each ecosystem:
- **React**: A `useVideoFrame()` hook that provides the current frame state and triggers re-renders automatically.
- **Svelte**: A readable store that developers can subscribe to with the `$` syntax for seamless reactivity.
- **Vue**: A composable function that returns a set of reactive properties for use in Vue's Composition API.

#### Playback via Web Components
For the in-browser preview, the player UI (scrubber, controls, etc.) is encapsulated as a standard **Web Component** (`<helios-player>`). This ensures maximum portability and isolation. The player can be dropped into any HTML page, regardless of the surrounding framework, without style or script conflicts. It uses a sandboxed `<iframe>` internally to render the user's composition, providing a clean and isolated environment for a true WYSIWYG preview.
### 2. The Animation System: A Modern, Performant Approach

> **Note on Animation for MVP**: The Web Animations API (WAAPI) approach described here is ideal for the versatile DOM-to-Video path. For the initial canvas-focused MVP, animations will be driven directly by the chosen canvas library's internal loop (e.g., a `requestAnimationFrame` loop in Three.js or Pixi.js). In this mode, Helios's role is to control the master timeline by providing the correct `currentTime` to the canvas on each frame.

A primitive approach to animation would require developers to write inefficient logic that re-runs on every single frame (e.g., `if (frame > 100) { opacity = 1; }`). Helios avoids this by leveraging the browser's native **Web Animations API (WAAPI)** for a more declarative and performant animation model.

The implementation is simple but powerful:
1.  **Declarative Animations**: Developers define their animations using standard, declarative web technologies they already know, such as CSS `@keyframes` or the `element.animate()` JavaScript method.
2.  **Timeline Control**: Instead of the library's render loop calling a user-defined function on every frame, it instead controls a global timeline. To render a specific frame `f` at a given `fps`, the engine performs a single, simple operation: it sets the timeline's current time programmatically to `document.timeline.currentTime = (f / fps) * 1000;`.

When the library sets the `currentTime`, the browser's own highly-optimized animation engine takes over. It calculates the correct interpolated values for all animated properties on all elements for that precise moment in time.

This architecture offers several profound advantages:
- **Performance**: It fundamentally decouples the animation definition from the rendering loop. The developer defines the animation *once*, and the browser handles the heavy lifting of calculating intermediate states for potentially thousands of properties, often off the main thread.
- **Maintainability**: Developers can express complex animations declaratively, which is more readable and less error-prone than writing manual interpolation logic for every frame.
- **Familiarity**: It unlocks the full power of the web platform, including complex easing functions, sequencing, and synchronization, using an API that is already a W3C standard.
### 3. The Rendering Pipeline: The Engine
The server-side engine transforms a composition into a final video file. It features a powerful dual-path architecture to intelligently select the most efficient rendering strategy based on the nature of the composition.

> **Note on Initial Implementation**: For the initial MVP, we will prioritize the **Canvas-to-Video** path. This approach offers superior performance and a faster path to a minimum viable product. The more versatile **DOM-to-Video** path is a planned feature for a subsequent release.

#### Path 1: DOM-to-Video (Versatile)
This path is a proven and versatile method for capturing any content that can be rendered in a web browser. It is ideal for compositions that rely on the standard DOM, including HTML elements, CSS styling, and SVG graphics.
- **Technology**: This path uses Playwright to launch a headless browser, render the full DOM for each frame, and capture a screenshot. A critical optimization is ensuring all assets (images, fonts, etc.) are fully pre-loaded before the render loop begins to prevent rendering artifacts.

#### Path 2: Canvas-to-Video (High-Performance)
This path provides a high-performance alternative for compositions that render exclusively to an HTML `<canvas>` element (e.g., using WebGL, Three.js, or Pixi.js). For these use cases, rendering a full DOM and taking a screenshot is inefficient overhead.
- **Technology**: This path uses the modern **WebCodecs API** to directly and efficiently encode canvas frames into video chunks. The engine captures the canvas content as a `VideoFrame` object, which is then fed into a hardware-accelerated `VideoEncoder`. This bypasses the DOM entirely for significant speed gains.
#### GPU Acceleration: A Foundational Requirement
For Helios, GPU acceleration is not an optional tweak but a **mandatory, foundational requirement** for competitive performance. By default, headless browsers often fall back to slow, CPU-based software rendering (like Google's SwiftShader), which is dramatically slower for graphics-intensive operations.

- **Implementation**: We will ship with optimized launch flags to enable hardware acceleration across different platforms (Linux, macOS, Windows).
- **Diagnostics**: To combat the common friction of environment configuration, the library will include a built-in diagnostic tool (`helios.diagnose()`) that programmatically checks `chrome://gpu` to verify that hardware acceleration is active and warns the user with helpful guidance if it is not. This transforms a potential point of failure into a guided, supportive developer experience.
#### Video & Audio Encoding with FFmpeg
All rendering paths feed their output into FFmpeg, the industry-standard tool for video manipulation.
- **Direct Execution**: We spawn FFmpeg directly as a child process from Node.js (`child_process.spawn`). This is a more stable and future-proof approach than relying on third-party JavaScript wrappers (like the deprecated `fluent-ffmpeg`), which can become outdated or introduce an unnecessary layer of abstraction.
- **Performance Optimization**: To minimize disk I/O, which is a major bottleneck, the engine pipes image data (as `Buffer`s) directly from the browser to FFmpeg's `stdin`, avoiding the need to write thousands of temporary frame files to disk. FFmpeg is configured to accept this piped input using the `image2pipe` demuxer.
- **Audio Integration**: The engine will support audio by using FFmpeg's powerful filter complex (e.g., `amix`) to mix multiple audio sources programmatically.
### 4. The In-Browser Player: A High-Fidelity Preview Engine
The in-browser player is crucial for providing developers with a rapid, iterative feedback loop. The key to a true "what you see is what you get" (WYSIWYG) experience is to use the exact same bundled composition code for both the in-browser preview and the final server-side render.

The fidelity of the preview is significantly improved by leveraging the same dual-path architecture:
- For **DOM-based** compositions, the player uses a `requestAnimationFrame` loop to drive the animation, providing a good approximation of the final output.
- For **canvas-based** compositions, the player can use the native browser WebCodecs API to generate a true video preview in real-time. This provides a preview that is much more accurate in terms of timing, performance, and final appearance than a simple frame loop.
## Technology Stack
- **Browser Automation: Playwright**: Chosen for its superior resilience, cross-browser support, and developer experience. While Puppeteer is a viable alternative, Playwright's architectural advantages are a better fit for a production-grade rendering engine.

| Feature | Puppeteer | Playwright | Recommendation & Rationale |
|---|---|---|---|
| **Auto-Waiting/Resilience** | Requires manual `waitFor` calls, a common source of flaky renders. | **Built-in auto-waiting** for elements to be actionable, drastically reducing flakiness. | **Playwright**. Resilience is paramount for a library rendering arbitrary user content. |
| **Cross-Browser Support** | Primarily Chromium. | **Native support for Chromium, Firefox, and WebKit.** | **Playwright**. Provides greater flexibility and future-proofs the library. |
| **Debugging Tools** | Basic debugging. | **Comprehensive suite** including Playwright Inspector and Trace Viewer. | **Playwright**. Superior tooling accelerates debugging for both library and end-user code. |

- **Video Encoding: FFmpeg**: Invoked directly via `child_process.spawn` for maximum control, stability, and performance.
- **Core Language: TypeScript**: For type safety, improved developer experience, and a more maintainable codebase.
- **Bundling: Vite / Rollup**: Modern, fast, and optimized for building libraries.
## Helios vs Remotion

Both Helios and [Remotion](https://www.remotion.dev/) enable programmatic video creation with web technologies. Here's what you need to know to choose.

### Quick Comparison

| | Helios | Remotion |
|---|---|---|
| **Learning curve** | Use what you know‚ÄîHTML, CSS, JS. Standard web animations. | React-specific APIs. Learn `useCurrentFrame()`, `interpolate()`, etc. |
| **Framework** | Any (React, Vue, Svelte, vanilla JS) | React only |
| **Animation approach** | CSS animations, Web Animations API | Frame-based hooks with manual interpolation |
| **Get started** | Drop a `<helios-player>` anywhere | React app with Remotion Studio |
| **Maturity** | Alpha (early stage) | Production-ready |
| **Pricing** | Free (ELv2) | Free for ‚â§3 devs, then $100+/mo |
| **Distributed rendering** | Planned | Available now (Lambda, Cloud Run) |

### Why Helios?

**Familiar APIs, zero learning curve.** If you can animate with CSS, you can animate with Helios. No new paradigms‚Äîjust use `@keyframes`, `element.animate()`, or your favorite animation library.

```css
/* Helios: Standard CSS animations just work */
@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

.my-element {
  animation: fadeIn 1s ease-out;
}
```

Compare this to Remotion's frame-based approach where you manually compute styles each frame:

```jsx
// Remotion: Manual interpolation on every frame
export const FadeIn = () => {
  const frame = useCurrentFrame();
  const opacity = interpolate(frame, [0, 30], [0, 1], {
    extrapolateRight: "clamp",
  });
  return <div style={{ opacity }}>Hello</div>;
};
```

The Helios approach means your existing CSS animations, GSAP timelines, or Motion/Framer Motion animations work out of the box. Remotion explicitly warns against CSS animations because their frame-based rendering can cause flickering‚Äîyou're locked into their `interpolate()` and `spring()` helpers.

**Use your preferred framework.** React, Vue, Svelte, or no framework at all. Helios provides idiomatic adapters for each:
- React: `useVideoFrame()` hook
- Vue: Composition API composables
- Svelte: Reactive stores
- Vanilla JS: Direct class instantiation

**Drop-in player component.** The `<helios-player>` Web Component works anywhere‚Äîno framework required, no style conflicts, no setup.

**Truly free for commercial use.** Build and sell products using Helios with no per-seat fees or render limits. The only restriction: you can't offer Helios itself as a hosted service. Remotion requires a company license at $100+/month once you have 4+ developers ($25/seat + $10/100 renders).

### Why Remotion?

**Battle-tested and production-ready.** Remotion has years of production use, extensive documentation, and a large community.

**Rich React ecosystem.** If you're building a React app, Remotion's deep integration with React hooks and components can be powerful.

**Distributed rendering today.** Remotion Lambda and Cloud Run are available now. Helios distributed rendering is planned for V2.

**Remotion Studio.** A built-in development environment with timeline preview and debugging tools.

### The Tradeoffs

**Helios prioritizes:**
- Getting started fast with familiar web APIs
- Framework flexibility
- Simple, predictable pricing (free)
- Performance for canvas/WebGL content (WebCodecs path)

**Remotion prioritizes:**
- React-native developer experience
- Mature, production-hardened infrastructure
- Immediate access to distributed rendering
- Comprehensive tooling (Studio, Lambda, Cloud Run)

### Honest Assessment

**Choose Helios if:**
- You want to prototype quickly without learning new APIs
- You're using Vue, Svelte, or vanilla JS
- You need canvas/WebGL performance (Three.js, Pixi.js)
- You want free commercial use without seat-based pricing
- You're comfortable with alpha software and want to shape the project

**Choose Remotion if:**
- You need production stability today
- You're all-in on React and prefer React patterns
- You need distributed rendering now
- You want extensive documentation and community support
- You don't mind per-seat licensing as your team grows

## Project Status
Alpha: This project is in the early stages of development. The architecture is defined, but the API is subject to change. We are actively seeking contributors to help shape the future of the project!
## Roadmap: The Future of Helios
Our vision extends beyond the initial release. Here are some of our future goals:
### V2: Distributed Rendering & Advanced Audio
- **Distributed Rendering**: We will implement a scalable, serverless rendering model inspired by Remotion Lambda. The architecture will split a video into `N` logical chunks and render them in parallel on platforms like AWS Lambda or Google Cloud Run.
  - **Critical Detail: Concatenation Strategy**: The success of this architecture hinges on the final merge step. FFmpeg's `concat` **demuxer** is the only method that can losslessly stitch MP4 chunks without a costly and quality-degrading re-encode. This is essential for a fast and efficient distributed workflow. Methods like the `concat` filter or protocol are unsuitable as they either re-encode or do not support the MP4 container format.
- **Advanced Audio Engine**: We plan to integrate a more sophisticated audio processing library (e.g., Tone.js) for creating generative audio and applying real-time effects programmatically.

### V3: Native Node.js Encoding
For the ultimate in performance, we will investigate replacing the spawned FFmpeg process with a library like **`beamcoder`**. This would provide direct Node.js bindings to FFmpeg's underlying C libraries, allowing for in-process encoding and eliminating the overhead of process spawning, albeit at the cost of increased build complexity.
## Deployment Strategies
A robust deployment strategy is essential for a server-side rendering tool. The architecture is designed to support both simple, single-machine deployments and highly scalable, distributed rendering on cloud infrastructure.

### Containerized Rendering with Docker
Docker is the ideal packaging and deployment mechanism for the rendering engine. It ensures a consistent, reproducible environment containing Node.js, a headless browser, FFmpeg, and all necessary dependencies for GPU acceleration. The container can be designed as a microservice, exposing an HTTP endpoint to accept render jobs.

### Distributed Rendering: AWS Lambda vs. Google Cloud Run
The architecture is designed to be container-native and platform-agnostic, giving users a choice of serverless platforms that fit their needs.

- **AWS Lambda**: Ideal for users prioritizing hyper-parallelism and minimum render time. Lambda is optimized for massive, fine-grained parallelism, which is perfect for splitting a video render across hundreds or thousands of concurrent function executions. This requires a chunking architecture and a final stitching step.
- **Google Cloud Run**: Ideal for users prioritizing simplicity and long-running jobs. Cloud Run can run standard Docker containers for extended periods (up to 24 hours), allowing a single container invocation to render an entire video from start to finish without the complexity of chunking and stitching.

#### Distributed Rendering Workflow and Concatenation
The success of a distributed rendering architecture hinges on the video concatenation strategy. Merging video chunks must be done without a costly re-encode. FFmpeg offers several methods, but only one is suitable:

| Method | How it Works | Supported Formats | Use Case for This Project |
|---|---|---|---|
| **Concat Demuxer** | Operates at the file level from a text file list. Can stream copy if codecs match. | All formats, including MP4. | **Recommended**. The only method for losslessly stitching MP4 chunks. |
| Concat Protocol | Operates at the bitstream level. | Simple stream formats (e.g., MPEG-2 PS). Not compatible with MP4. | Unsuitable. Will fail or corrupt MP4 files. |
| Concat Filter | A complex filter that decodes and re-encodes frames. | All formats. | Unsuitable. Re-encoding is slow and causes quality loss. |

The distributed workflow is as follows:
1.  **Orchestration**: A coordinator function (e.g., AWS Step Function) divides the video into `N` logical chunks (e.g., frames 0-299, 300-599, etc.).
2.  **Parallel Execution**: The orchestrator invokes `N` parallel workers (e.g., Lambda functions), assigning each a frame range.
3.  **Chunk Rendering**: Each worker renders its video and audio segments as separate files (e.g., `chunk_1.mp4`, `chunk_1.aac`) and uploads them to a shared location like S3.
4.  **Final Stitching**: A final assembly job uses FFmpeg's `concat` demuxer to perform a fast, lossless merge of the video and audio chunks into the final output file.

### Development Workflow & Debugging
A seamless local development workflow is crucial for productivity. We recommend a hot-reloading environment for developers working on the library itself or on compositions using it.

- **Hot Reloading**: A recommended setup involves using `npm link` or `yarn link` to link your local library source code to a sample project (e.g., a Vite + React app). Running the library's bundler in "watch" mode alongside the sample project's dev server provides a near-instant feedback loop.
- **Debugging**: Debugging issues inside a headless browser can be challenging. We provide several tools to make it easier:
  - **Headed Mode**: Run the render process in a visible browser window using a `--headed` flag. Often, simply watching the automation unfold is the fastest way to spot an issue.
  - **Remote Debugging**: A `--debug` flag can launch the browser with a remote debugging port open. This allows you to connect the familiar Chrome DevTools to the headless instance to inspect the DOM, view console logs, and debug JavaScript live.
  - **Playwright Trace Viewer**: For post-mortem analysis, you can enable Playwright's Trace Viewer. It captures a complete trace of a render, including a video screencast, live DOM snapshots, console logs, and network requests, which is invaluable for diagnosing failed renders.

## License

Helios Engine is licensed under the **Elastic License 2.0 (ELv2)**. This license is designed to encourage widespread adoption while protecting our ability to build a SaaS platform.

### What This Means

**You Can:**
- ‚úÖ **Build commercial products** - Use Helios Engine in any commercial application or product
- ‚úÖ **Embed in applications** - Include Helios Engine in your software, whether open source or proprietary
- ‚úÖ **Modify and distribute** - Fork, modify, and distribute Helios Engine
- ‚úÖ **Create video platforms** - Build video creation tools, editors, or platforms using Helios Engine
- ‚úÖ **Use internally** - Use Helios Engine for internal business purposes without restrictions
- ‚úÖ **Sell products** - Sell products that use or include Helios Engine
- ‚úÖ **Contribute** - Contribute improvements back to the open source project

**You Cannot:**
- ‚ùå **Offer Helios as a managed service** - You cannot provide Helios Engine as a hosted/managed service (SaaS) to third parties
- ‚ùå **Resell Helios infrastructure** - You cannot offer Helios Engine rendering infrastructure as a service

**What This Means in Practice:**

This license is **perfect for founders building video platforms**. You can:
- Build a video editing SaaS platform using Helios Engine ‚úÖ
- Create a video generation tool for your customers ‚úÖ
- Build a white-label video creation platform ‚úÖ
- Embed Helios Engine in your application ‚úÖ
- Sell products that use Helios Engine ‚úÖ

You just can't offer Helios Engine itself as a managed/hosted service to others.

### Why Elastic License 2.0?

We chose Elastic License 2.0 because:
- **Encourages adoption** - Developers can build commercial products without restrictions
- **Protects SaaS opportunity** - Prevents competitors from offering Helios as a managed service
- **Well-established** - Used by Elasticsearch, Kibana, and other successful projects
- **Clear boundaries** - Simple rule: build products ‚úÖ, offer managed services ‚ùå
- **Founder-friendly** - Perfect for founders building video platforms (our target customers!)

This license allows us to build a SaaS platform around Helios while enabling a thriving ecosystem of products built on top of it.

### Commercial Licensing

If you need to offer Helios Engine as a managed service or have questions about commercial licensing, please [contact us](mailto:me@gavinbintz.com).

## Services & Commercial Offerings

Helios Engine is free and open source, allowing you to build video creation applications without restrictions. To support ongoing development and provide managed infrastructure, we plan to offer the following commercial services in the future:

### Helios API (API as a Service) üöÄ *Primary Service*

**Programmatic video rendering without managing infrastructure.**

Render videos programmatically via REST API. Ideal for developers who want to integrate video creation into their applications without managing rendering infrastructure, GPU acceleration, or distributed rendering systems.

**Planned Features:**
- **REST API** - Simple HTTP endpoints for video rendering
- **Webhook notifications** - Get notified when renders complete
- **Queue management** - Priority queues, batch rendering, job status tracking
- **Distributed rendering** - Leverage our infrastructure for fast, scalable rendering
- **Multiple formats** - MP4, WebM, GIF, and more
- **Custom resolutions** - Render at any resolution up to 4K
- **SDKs** - Official SDKs for popular languages (JavaScript, Python, etc.)

**Use Cases:**
- Integrate video generation into your SaaS platform
- Build automated video workflows
- Generate personalized videos at scale
- Create video content from templates and data
- Add video creation capabilities to existing applications

**Pricing Model (Planned):**
- **Pay-as-you-go** - Per-minute rendering costs
- **Render credits** - Bulk purchases with discounts
- **Free tier** - Limited renders per month for testing and development
- **Enterprise plans** - Custom pricing with SLA guarantees, dedicated infrastructure

This service is designed for developers and teams who want the power of Helios Engine without the complexity of managing rendering infrastructure. Perfect for founders building video platforms who need reliable, scalable rendering infrastructure.

### Helios Cloud (Managed Platform)

**A hosted video creation platform powered by Helios Engine.**

A full-featured SaaS platform for creating, editing, and managing videos. Built on Helios Engine, providing a user-friendly interface for non-technical users while leveraging the performance of the underlying engine.

**Planned Features:**
- Web-based video editor
- Integrations with data sources (e.g. databases, APIs)
- Template library with pre-built templates for common use cases
- Collaboration tools for teams
- Asset management (images, videos, audio, fonts)
- Analytics and insights

**Target Users:**
- Content creators
- Marketing teams
- Agencies
- Non-technical users who want video creation capabilities

### Enterprise Services

**For organizations with advanced requirements:**

- **Enterprise Support** - SLA-backed support, dedicated account management, priority assistance
- **Professional Services** - Custom implementations, integrations, architecture consulting
- **On-Premise Deployments** - Self-hosted Helios Engine for organizations with security/compliance requirements
- **Commercial Licensing** - For companies that want to offer Helios Engine as a managed service to their customers
- **Training & Certification** - Developer training, best practices workshops, official certification programs

### Marketplace & Ecosystem

**A marketplace for Helios extensions and assets:**

- **Template Marketplace** - Video templates created by the community
- **Plugin System** - Extensions and integrations for Helios Engine
- **Asset Marketplace** - Stock footage, music, graphics optimized for Helios
- **Integration Marketplace** - Pre-built integrations with popular tools and platforms

### Our Business Model

**Free engine, paid infrastructure and services.**

Similar to successful open-source companies like MongoDB (Atlas), Elastic (Elastic Cloud), and GitLab (GitLab.com), we believe in:

- **Open source core** - Helios Engine remains free and open source forever
- **Managed services** - Pay for convenience, scale, and support
- **Ecosystem growth** - Marketplace and community-driven extensions

This model ensures:
- ‚úÖ Unlimited adoption of Helios Engine (no licensing barriers)
- ‚úÖ Sustainable business to support long-term development
- ‚úÖ Thriving ecosystem of products built on Helios
- ‚úÖ Multiple options for users (self-hosted or managed services)

**For developers:** Use Helios Engine for free. Build your applications, deploy your own infrastructure, and scale as needed.

**For teams that want managed infrastructure:** Use Helios API or Helios Cloud to offload infrastructure management and focus on building your product.

We're committed to keeping Helios Engine open source and free, while building sustainable commercial services that add value for teams that need managed infrastructure and support.

See [LICENSE](LICENSE) for the full license text.
