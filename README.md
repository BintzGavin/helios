<!-- AGENT_SKIP_START: This section is for human readers only. Planning agents should skip to the next section. -->
<details>
<summary>DISCLAIMER: This repository is an active experiment in autonomous software engineering.</summary>


> **Current Status:** üöÄ **Beta / Self-Driving**

This codebase is primarily managed and developed by a fleet of AI agents running on **Google's Jules** platform. It is **not** currently intended for production use.

### How It Works
The system uses a **Black Hole Architecture**‚Äîa planning-execution cycle designed to simulate a fully autonomous engineering team where agents continuously pull the codebase toward the documented vision:

1.  **Autonomous Scheduling:** "Prompts" are executed daily to drive the development lifecycle.
    * **Morning Phase:** Planning agents scan the codebase and `README` vision, identifying missing features or bugs to populate their own backlog.
    * **Afternoon Phase:** Execution agents implement the planned tasks.
    * **End-of-Day Phase:** Scribe agent consolidates progress logs and regenerates the context knowledge base for the next day's planning cycle.
2.  **Feedback Loops:** Agents are empowered to run their own validation using:
    * **Playwright** for End-to-End (E2E) testing.
    * **Visual Regression** via screenshot analysis.
    * **Unit Tests** (Vitest) for logic verification.
    * **Ad-hoc Bash Commands** for environment diagnostics.
3.  **Human-in-the-Loop:** While I act as the "Lead Architect" providing the high-level vision, my involvement is primarily limited to glancing at and merging Pull Requests generated by **Jules** and reviewed by a separate **GitHub Copilot** agent.

### Agent Prompts

For transparency and educational purposes, the complete prompts used to orchestrate the agent swarm are available in the [`docs/prompts/`](./docs/prompts/) directory.

**Expect rapid changes, experimental commits, and occasional "hallucinated" refactors as the swarm learns to optimize its own workflow.**
</details>
<!-- AGENT_SKIP_END -->

<div align="center">

# ‚òÄÔ∏è Helios

### Video is Light Over Time

[![License](https://img.shields.io/badge/license-ELv2-blue.svg)](LICENSE)
[![Status](https://img.shields.io/badge/status-beta-yellow.svg)](#project-status)
[![TypeScript](https://img.shields.io/badge/TypeScript-5.0-blue.svg)](https://www.typescriptlang.org/)
[![Node](https://img.shields.io/badge/node-%3E%3D18.0.0-brightgreen.svg)](https://nodejs.org/)
[![npm](https://img.shields.io/badge/npm-workspace-red.svg)](https://www.npmjs.com/)
[![GitHub](https://img.shields.io/badge/GitHub-BintzGavin%2Fhelios-black.svg)](https://github.com/BintzGavin/helios)
[![Made with](https://img.shields.io/badge/made%20with-AI%20Agents-purple.svg)](./docs/prompts/)

**A programmatic video engine that runs on web standards.**  
Stop reinventing animation in JavaScript. Use the platform.

[The Thesis](#the-thesis) ‚Ä¢ [Quick Start](#quick-start) ‚Ä¢ [Why Helios?](#why-helios) ‚Ä¢ [Documentation](#architecture) ‚Ä¢ [Roadmap](#roadmap-the-future-of-helios)

</div>


https://github.com/user-attachments/assets/89ee2a20-77c5-4440-ad68-9f9180d969bd


(Video created with Helios)


---

## The Thesis

### Native Always Wins

The history of software teaches a consistent lesson: **betting on native platform capabilities almost always beats simulation.**

- CSS animations replaced jQuery `.animate()` and JS-driven motion
- Native `<video>` and `<audio>` killed Flash
- IntersectionObserver replaced expensive scroll-listener hacks
- CSS Scroll Snap is displacing JavaScript carousel libraries

When the platform catches up, the abstractions built to work around it become legacy debt.

### The Remotion Era: Simulating What the Browser Already Does

[Remotion](https://www.remotion.dev/) solved programmatic video by treating the browser as a **static image generator**. Stop time. Inject a frame number. Render. Screenshot. Repeat 30 times per second.

```typescript
// Remotion: The browser is a screenshot machine
function MyComponent() {
  const frame = useCurrentFrame();  // Frame number injected from outside
  const opacity = interpolate(frame, [0, 30], [0, 1]);  // YOU calculate every value
  return <div style={{ opacity }}>Hello</div>;
}
```

This works. It's deterministic. Remotion is brilliant engineering, battle-tested, and has earned its place as the market leader.

But look at what this architecture requires: **reimplementing animation in JavaScript.** The browser has a world-class animation engine‚ÄîCSS `@keyframes`, hardware-accelerated compositing, the Web Animations API‚Äîbut the frame-based model says: *"Ignore all of that. We'll simulate it ourselves."*

Your CSS animations? Broken‚Äîthe system clock drifts during render.  
Your GSAP timelines? Need custom integration.  
The browser's C++ compositor? Bypassed entirely.

This is a **simulation-based architecture**. It works *despite* the browser, not *with* it.

### The Helios Bet: Drive the Browser, Don't Simulate It

Helios takes a different bet: **what if we drove the browser's native animation engine instead of replacing it?**

The approach varies by context:

**For Production Rendering:** Helios uses the Chrome DevTools Protocol (CDP) to virtualize time at the environment level. The `Emulation.setVirtualTimePolicy` command detaches the browser's internal clock from wall-clock time, allowing the renderer to advance time frame-by-frame as fast as the CPU allows. The browser's native animation engine calculates all interpolated values‚Äîwe just tell it what time it is.

**For Preview/Development:** Helios uses the Web Animations API to seek individual animations. Every `Animation` object has a writable `.currentTime` property:

```typescript
// Seek all animations to 1.5 seconds
document.getAnimations().forEach(anim => {
  anim.currentTime = 1500;
  anim.pause();
});
```

When you set `animation.currentTime`, the browser's C++ rendering engine recalculates all interpolated values. Hardware-accelerated. Using the same optimized code that powers every CSS animation on the web.

**The result for developers:**

```css
/* Your existing CSS. No changes. */
@keyframes fadeIn {
  from { opacity: 0; transform: scale(0.9); }
  to { opacity: 1; transform: scale(1); }
}

.my-element {
  animation: fadeIn 1s ease-out forwards;
}
```

```typescript
// Helios drives the browser's animation engine
const helios = new Helios({ duration: 10, fps: 30, autoSyncAnimations: true });
helios.seek(45); // All CSS/WAAPI animations instantly update to frame 45
```

**That's it.** Your CSS animations, your GSAP timelines, your Framer Motion springs‚Äîthey work because the browser is doing the animation, not JavaScript.

### The Honest Trade-off

This is a **native-aligned architecture**, but it's not without constraints:

- **Browser-specific:** CDP is Chromium-only. Helios renders in headless Chrome.
- **Non-standard time control:** The W3C spec marks `document.timeline.currentTime` as read-only. We work around this via protocol-level control, not by violating the spec.
- **A bet, not a certainty:** We're betting that platform capabilities will mature and this approach will become standard. If we're wrong, simulation-based architectures like Remotion will continue to dominate.

But if history is any guide‚Äînative mobile vs PhoneGap, CSS Grid vs JavaScript layouts, `fetch()` vs jQuery‚Äînative-aligned architectures eventually win.

We named this engine after the sun because video is, fundamentally, *light over time*.

---

## Quick Start

### Installation

```bash
npm install @helios-project/core @helios-project/player
```

### Create a Composition

```typescript
import { Helios } from '@helios-engine/core';

// Create a 10-second video at 30fps
const helios = new Helios({
  duration: 10,
  fps: 30,
  autoSyncAnimations: true
});

// Subscribe to frame updates
helios.subscribe(({ currentFrame, duration, fps }) => {
  const progress = currentFrame / (duration * fps);
  // Use progress (0-1) to drive your animations
  document.querySelector('.my-element').style.opacity = progress;
});

// Control playback
helios.play();
helios.pause();
helios.seek(150); // Jump to frame 150
```

### Use Standard CSS Animations

```css
/* Your existing CSS animations just work */
@keyframes fadeIn {
  from { opacity: 0; transform: scale(0.9); }
  to { opacity: 1; transform: scale(1); }
}

.my-element {
  animation: fadeIn 1s ease-out;
}
```

### Preview with the Player

```html
<!-- Drop-in Web Component works anywhere -->
<helios-player src="./composition.html" width="1920" height="1080"></helios-player>
<script type="module" src="@helios-project/player"></script>
```

### Render to Video

```bash
npx helios render ./composition.html -o output.mp4
```

---

## Why Helios?

### Use What You Know

No proprietary APIs to learn. Your existing CSS animations, GSAP timelines, and Motion/Framer Motion animations work out of the box.

| Helios | Remotion |
|--------|----------|
| `@keyframes fadeIn { ... }` | `interpolate(frame, [0, 30], [0, 1])` |
| Standard CSS, WAAPI | Custom hooks on every frame |
| Any animation library | Must use their helpers |

### Any Framework (or None)

```typescript
// React
const { currentFrame } = useVideoFrame();

// Vue
const { currentFrame } = useVideoFrame();

// Svelte
$: currentFrame = $videoFrame.currentFrame;

// Vanilla JS
helios.subscribe(state => console.log(state.currentFrame));
```

### Free for Commercial Use

Build and sell products with Helios. No per-seat fees, no render limits.

| | Helios | Remotion |
|---|--------|----------|
| **Solo developer** | Free | Free |
| **4-person team** | Free | $100/mo |
| **10-person team** | Free | $250/mo |
| **100 renders/mo** | Free | +$10/mo |

---

## Core Principles

<!-- AGENT_VISION_START: These principles guide all architectural decisions -->

The development of Helios is guided by foundational principles that inform every architectural decision:

### Agent Experience First
As AI agents become primary users of developer tools, Helios prioritizes **Agent Experience (AX)**‚Äîthe holistic experience AI agents have when using our APIs and platform. Great AX means:
- **Predictable APIs** - Consistent patterns, no magic
- **Clear error messages** - Machine-readable, actionable errors
- **Machine-readable documentation** - Structured for LLM consumption
- **Composable primitives** - Work well with LLM-driven workflows

DX and AX are deeply aligned‚Äîwhat works for agents works for humans too.

### Prototype Fast, Scale Later
Start with a simple composition, preview instantly in your browser, and only worry about rendering infrastructure when you're ready to ship.

### Use What You Know
Pure TypeScript with zero framework dependencies. Use React, Vue, Svelte, or vanilla JS‚Äîwhatever you're already comfortable with.

### Leverage Web Standards
Native browser APIs over custom implementations. CSS animations, Web Animations API (WAAPI), and standard DOM APIs. Your existing web development skills transfer directly.

### Performance When It Matters
Hardware-accelerated rendering, in-memory data piping, and WebCodecs support for canvas-heavy work. Performance is there when you need it.

<!-- AGENT_VISION_END -->

---

## AI & Agent Integration

Helios is designed from the ground up for AI-assisted development. Whether you're using Claude, Cursor, GitHub Copilot, or autonomous agent systems, Helios provides first-class support.

### For AI Coding Assistants

**AI-Ready Documentation:**
- **llms.txt** - Machine-readable project overview at [`/llms.txt`](./llms.txt)
- **Markdown URLs** - Add `.md` to any doc URL for raw markdown (planned)
- **Structured errors** - All errors are machine-parseable with actionable guidance

**Agent Skills:**
Skills are installable best-practice guides for AI agents. Located in `.agents/skills/helios/`:
- `core/SKILL.md` - Core API patterns
- `renderer/SKILL.md` - Rendering pipeline (planned)
- `player/SKILL.md` - Player component (planned)
- `workflows/` - Common task workflows (planned)

```bash
# Coming soon: Install Helios skills for your AI agent
npx @helios-engine/skills install
```

### For Autonomous Agent Systems

Helios uses a **Black Hole Architecture** where AI agents continuously pull the codebase toward this documented vision. If you're building similar systems:

- **Vision Document**: This README serves as the authoritative vision. Planning agents scan it to identify gaps.
- **Status Files**: `docs/status/[ROLE].md` tracks each domain's progress
- **Progress Log**: `docs/PROGRESS.md` records completed work
- **Backlog**: `docs/BACKLOG.md` tracks planned features
- **Context Files**: `.sys/llmdocs/context-*.md` provides architectural summaries

See [`docs/prompts/`](./docs/prompts/) for the complete agent orchestration system.

### Diagnostics for AI Environments

```typescript
// Check environment capabilities (useful for AI debugging)
const report = await Helios.diagnose();
console.log(report);
// {
//   waapi: true,           // Web Animations API
//   webCodecs: true,       // VideoEncoder support
//   offscreenCanvas: true,
//   userAgent: "..."
// }
```

---

## Helios vs Remotion

Both Helios and [Remotion](https://www.remotion.dev/) enable programmatic video creation. Here's an honest comparison:

### Philosophical Difference

| | Helios | Remotion |
|---|--------|----------|
| **Architecture** | Native-aligned (drive the browser's engine) | Simulation-based (treat browser as screenshot machine) |
| **Animation Calculation** | Browser's C++ compositor | JavaScript on every frame |
| **Time Control** | CDP virtual time (production) / WAAPI seeking (preview) | React state propagation |
| **CSS `@keyframes`** | ‚úÖ Work natively | ‚ùå Clock drifts during render |
| **Browser Dependency** | Chromium (CDP required) | Any browser (pure JS) |
| **Historical Analog** | Native apps, CSS Grid, `fetch()` | PhoneGap, layout.js, jQuery AJAX |
| **Bet** | Platform capabilities will mature | Abstraction layer will remain necessary |

### Feature Comparison

| Feature | Helios | Remotion |
|---------|--------|----------|
| **Framework** | Any (React, Vue, Svelte, vanilla) | React only |
| **Animation** | CSS, WAAPI, any library | `interpolate()`, `spring()` hooks |
| **Learning curve** | Use what you know | Learn Remotion APIs |
| **Maturity** | üü° Beta | üü¢ Production-ready |
| **Pricing** | Free (ELv2) | Free ‚â§3 devs, then $100+/mo |
| **Studio IDE** | üü¢ Beta | üü¢ Available |
| **Distributed rendering** | üü° Beta (Local Orchestrator) | üü¢ Lambda, Cloud Run |
| **Captions/subtitles** | üü° Standard (SRT) | üü¢ Built-in |
| **Audio mixing** | üü¢ Client-side (WebCodecs) | üü¢ Advanced |
| **MCP Server** | üü° Planned | üü¢ Available |
| **Agent Skills** | üü° Local only | üü¢ `npx skills add` |
| **Transitions library** | üü¢ Available | üü¢ `@remotion/transitions` |
| **Sequence/Series** | üî¥ Not yet | üü¢ Built-in components |

### Where Helios Wins

- **Framework freedom** - Use React, Vue, Svelte, or vanilla JS
- **Zero learning curve** - Standard web animations work out of the box
- **Free commercial use** - No per-seat or per-render fees
- **Canvas/WebGL performance** - WebCodecs path for Three.js, Pixi.js
- **Agent-first design** - Built for AI-assisted workflows

### Where Remotion Wins

- **Production maturity** - Years of battle-testing
- **Distributed rendering** - Lambda and Cloud Run today
- **Rich ecosystem** - Transitions, captions, templates
- **Studio IDE** - Full development environment
- **Documentation depth** - Extensive guides and examples

### Choose Helios If

- You want familiar web APIs, not proprietary hooks
- You're using Vue, Svelte, or vanilla JS
- You need canvas/WebGL performance (Three.js, Pixi.js)
- You want free commercial use without licensing complexity
- You're comfortable with alpha software

### Choose Remotion If

- You need production stability today
- You're all-in on React
- You need distributed rendering now
- You want extensive documentation and community

---

## Architecture

<!-- AGENT_ARCHITECTURE_START: Detailed architecture for planning agents -->

Helios is designed with a modular architecture that separates logic from presentation.

### 1. The Composition Layer

#### Headless Logic Engine
The core is an instantiable JavaScript class that manages all state (`currentFrame`, `duration`, `isPlaying`, `inputProps`), exposes methods (`play`, `pause`, `seek`), and provides subscription-based reactivity. This decouples logic from any UI framework.

#### Framework Adapters
Lightweight packages expose the headless engine idiomatically for each framework:
- **React**: `useVideoFrame()` hook
- **Vue**: Composition API composables  
- **Svelte**: Readable stores with `$` syntax
- **Vanilla**: Direct class instantiation

#### Web Component Player
The `<helios-player>` Web Component encapsulates the preview UI. It uses a sandboxed iframe internally for isolation, ensuring it works in any HTML page without conflicts.

### 2. The Animation System

Helios drives the browser's native animation engine rather than simulating animation in JavaScript. The mechanism varies by context:

#### Production Rendering (Headless Chrome)
Uses Chrome DevTools Protocol to virtualize time:
```
CDP: Emulation.setVirtualTimePolicy({ policy: 'advance', budget: 33.33 })
‚Üí Browser advances internal clock by exactly 33.33ms
‚Üí All CSS/WAAPI animations update to new time
‚Üí Layout and paint complete
‚Üí Frame captured
```

This is deterministic: the browser cannot advance until each frame is fully rendered, regardless of scene complexity.

#### Preview Mode (Browser Tab)
Uses WAAPI's writable `Animation.currentTime`:
```typescript
// Seek all animations to target time
document.getAnimations().forEach(anim => {
  anim.currentTime = targetTimeMs;
  anim.pause();
});
```

This is an O(N) operation over animations, but lets developers preview without running a headless browser.

**Advantages:**
- Performance: Animation interpolation happens in the browser's C++ compositor
- Maintainability: Declarative CSS over imperative JavaScript
- Familiarity: Standard CSS and WAAPI‚Äîskills transfer directly

> **Canvas MVP Note**: For canvas compositions (Three.js, Pixi.js), Helios provides `currentTime` to the canvas's internal render loop rather than controlling WAAPI.

### 3. The Rendering Pipeline

Dual-path architecture selects the optimal strategy:

#### Path 1: DOM-to-Video (Versatile)
- Uses Playwright to render DOM, capture screenshots
- Ideal for HTML, CSS, SVG compositions
- Asset preloading prevents artifacts

#### Path 2: Canvas-to-Video (High-Performance)
- Uses WebCodecs API for direct frame encoding
- Hardware-accelerated VideoEncoder
- Bypasses DOM for significant speed gains
- **This is the MVP priority path**

#### GPU Acceleration
GPU acceleration is mandatory for competitive performance. The library ships with optimized browser launch flags and includes `helios.diagnose()` to verify hardware acceleration.

#### FFmpeg Integration
- Direct `child_process.spawn` (no wrappers)
- In-memory piping via `image2pipe` demuxer (no temp files)
- Audio mixing via filter complex

### 4. The In-Browser Player

WYSIWYG preview using the same bundled composition code as the final render:
- DOM compositions: `requestAnimationFrame` loop
- Canvas compositions: WebCodecs real-time preview

<!-- AGENT_ARCHITECTURE_END -->

---

## Technology Stack

| Component | Choice | Rationale |
|-----------|--------|-----------|
| **Browser Automation** | Playwright | Auto-waiting, cross-browser support, superior debugging (Trace Viewer, Inspector) |
| **Video Encoding** | FFmpeg (spawn) | Direct `child_process.spawn` for maximum control, stability, and performance |
| **Language** | TypeScript | Type safety, improved DX, maintainable codebase |
| **Bundling** | Vite/Rollup | Modern, fast, optimized for building libraries |

---

## Project Status

**Beta**: Architecture stable, API maturing, suitable for early adopters.

### Current Capabilities
- ‚úÖ Core `Helios` class with timeline control
- ‚úÖ Helios Studio (Beta)
- ‚úÖ Animation Helpers (`interpolate`, `spring`)
- ‚úÖ Captions Support (SRT parsing/rendering)
- ‚úÖ AI Integration (System Prompts)
- ‚úÖ Canvas-to-Video rendering path
- ‚úÖ `<helios-player>` Web Component
- ‚úÖ React, Vue examples
- ‚úÖ FFmpeg integration with piped frames
- ‚úÖ `helios.diagnose()` environment checks
- ‚úÖ Client-side export (WebCodecs) with Audio Mixing & Captions
- ‚úÖ Distributed Rendering (Local Orchestrator)
- ‚úÖ Lottie Integration (React, Vue)
- ‚úÖ Audio Visualization Examples
- ‚úÖ Audio Tracks API


See [`docs/BACKLOG.md`](./docs/BACKLOG.md) for the full task list.

---

## Roadmap: The Future of Helios

<!-- AGENT_ROADMAP_START: Planning agents use this to identify features to build -->

### V1.x: Captions & Audio
**Planned:**
- Caption generation via Whisper integration
- Text-to-speech integration

### V1.x: AI Integration Parity
**Planned:**
- MCP Server (`@helios-engine/mcp`) for Cursor/VS Code
- Publishable Agent Skills (`npx @helios-engine/skills add`)
- AI chatbot for documentation help
- `.md` URL suffix for documentation

### V1.x: Architecture Hardening

Three structural improvements to move Helios from "clever hack" to "stable standard":

#### 1. TimeDriver Abstraction

Currently, Helios's time control relies on CDP hacks (production) and WAAPI seeking (preview). This works, but couples the library to implementation details that browsers could tighten.

**The Fix:** Introduce a `TimeDriver` interface that abstracts the source of truth for time.

```typescript
// User code (clean API)
director.seek(1500); // Seek to 1.5 seconds

// Under the hood:
// - Preview: TimeDriver updates CSS variables or WAAPI currentTime
// - Production: TimeDriver calls CDP setVirtualTimePolicy
```

**Why:** This decoupling protects the library from breaking when browsers inevitably tighten security around read-only native properties. The public API stays stable even as the underlying mechanism evolves.

#### 2. Signal-Based State

Remotion ties frame numbers to React State. This is its biggest performance bottleneck‚ÄîReact is not designed to re-render a component tree 60 times per second. It creates massive garbage collection overhead and "jank."

**The Fix:** Adopt a Signal-based architecture (similar to SolidJS or Preact Signals) for the animation loop.

```typescript
// Signals: fine-grained updates
const opacity = signal(0);
opacity.value = 1; // Only the bound DOM node updates‚Äînot the entire tree
```

**Why:** Signals allow fine-grained updates. Changing `opacity` from 0 to 1 updates only that DOM node's style attribute‚Äînot the entire component tree. This would allow Helios to render scenes with thousands of animated elements at 60 FPS in the previewer, whereas Remotion often drops to 5-10 FPS on complex timelines because it's thrashing the React Reconciler.

#### 3. Client-Side WebCodecs as Primary Export

Currently, Helios supports WebCodecs but server-side rendering (headless Chrome + FFmpeg) remains the primary path. Remotion has the same architecture‚Äîexpensive servers, slow to scale.

**The Fix:** Fully commit to **client-side WebCodecs as the primary export target**.

```typescript
// User's browser does all the work
const encoder = new VideoEncoder({ ... });
// ‚Üí Render to OffscreenCanvas
// ‚Üí Encode with local GPU
// ‚Üí Download MP4 directly
```

**Why:** This creates a "Canva-like" experience where the user's own hardware does the compute, reducing infrastructure costs to near zero. Server-side rendering becomes a fallback for low-power devices or background batch jobs‚Äînot the default.

| Export Path | Current | Planned |
|-------------|---------|---------|
| **Primary** | Server (Headless Chrome + FFmpeg) | Client (WebCodecs + local GPU) |
| **Fallback** | Client (experimental) | Server (batch/low-power devices) |

### V2: Distributed Rendering
Scalable serverless rendering on AWS Lambda or Google Cloud Run.

**Status:** üü° **Beta (Local Orchestrator Implemented)**

**Architecture:**
1. Orchestrator divides video into N frame-range chunks
2. N parallel workers render chunks
3. FFmpeg `concat` demuxer losslessly stitches MP4 chunks

**Critical Detail:** Only the concat *demuxer* supports lossless MP4 stitching. The concat filter and protocol are unsuitable.

### V2: Advanced Audio Engine
Integration with Tone.js for generative audio and real-time effects.

### V3: Native Node.js Encoding
Replace spawned FFmpeg with `beamcoder` for in-process encoding via FFmpeg C bindings.

<!-- AGENT_ROADMAP_END -->

---

## Deployment Strategies

A robust deployment strategy is essential for a server-side rendering tool. The architecture is designed to support both simple, single-machine deployments and highly scalable, distributed rendering on cloud infrastructure.

### Containerized Rendering with Docker

Docker is the ideal packaging and deployment mechanism for the rendering engine. It ensures a consistent, reproducible environment containing Node.js, a headless browser, FFmpeg, and all necessary dependencies for GPU acceleration. The container can be designed as a microservice, exposing an HTTP endpoint to accept render jobs.

### Distributed Rendering: AWS Lambda vs. Google Cloud Run

The architecture is designed to be container-native and platform-agnostic, giving users a choice of serverless platforms that fit their needs.

- **AWS Lambda**: Ideal for users prioritizing hyper-parallelism and minimum render time. Lambda is optimized for massive, fine-grained parallelism, which is perfect for splitting a video render across hundreds or thousands of concurrent function executions. This requires a chunking architecture and a final stitching step.
- **Google Cloud Run**: Ideal for users prioritizing simplicity and long-running jobs. Cloud Run can run standard Docker containers for extended periods (up to 24 hours), allowing a single container invocation to render an entire video from start to finish without the complexity of chunking and stitching.

### Distributed Rendering Workflow and Concatenation

The success of a distributed rendering architecture hinges on the video concatenation strategy. Merging video chunks must be done without a costly re-encode. FFmpeg offers several methods, but only one is suitable:

| Method | How it Works | Supported Formats | Use Case for This Project |
|---|---|---|---|
| **Concat Demuxer** | Operates at the file level from a text file list. Can stream copy if codecs match. | All formats, including MP4. | **Recommended**. The only method for losslessly stitching MP4 chunks. |
| Concat Protocol | Operates at the bitstream level. | Simple stream formats (e.g., MPEG-2 PS). Not compatible with MP4. | Unsuitable. Will fail or corrupt MP4 files. |
| Concat Filter | A complex filter that decodes and re-encodes frames. | All formats. | Unsuitable. Re-encoding is slow and causes quality loss. |

The distributed workflow is as follows:
1. **Orchestration**: A coordinator function (e.g., AWS Step Function) divides the video into `N` logical chunks (e.g., frames 0-299, 300-599, etc.).
2. **Parallel Execution**: The orchestrator invokes `N` parallel workers (e.g., Lambda functions), assigning each a frame range.
3. **Chunk Rendering**: Each worker renders its video and audio segments as separate files (e.g., `chunk_1.mp4`, `chunk_1.aac`) and uploads them to a shared location like S3.
4. **Final Stitching**: A final assembly job uses FFmpeg's `concat` demuxer to perform a fast, lossless merge of the video and audio chunks into the final output file.

---

## Development

### Local Setup

```bash
git clone https://github.com/gavinbintz/helios.git
cd helios
npm install
npm run dev
```

### Testing

```bash
npm test                           # All tests
npm test -w packages/core          # Core package only
npm run render:canvas-example      # Test render pipeline
```

### Development Workflow & Debugging

A seamless local development workflow is crucial for productivity. We recommend a hot-reloading environment for developers working on the library itself or on compositions using it.

- **Hot Reloading**: A recommended setup involves using `npm link` or `yarn link` to link your local library source code to a sample project (e.g., a Vite + React app). Running the library's bundler in "watch" mode alongside the sample project's dev server provides a near-instant feedback loop.
- **Debugging**: Debugging issues inside a headless browser can be challenging. We provide several tools to make it easier:
  - **Headed Mode**: Run the render process in a visible browser window using a `--headed` flag. Often, simply watching the automation unfold is the fastest way to spot an issue.
  - **Remote Debugging**: A `--debug` flag can launch the browser with a remote debugging port open. This allows you to connect the familiar Chrome DevTools to the headless instance to inspect the DOM, view console logs, and debug JavaScript live.
  - **Playwright Trace Viewer**: For post-mortem analysis, you can enable Playwright's Trace Viewer. It captures a complete trace of a render, including a video screencast, live DOM snapshots, console logs, and network requests, which is invaluable for diagnosing failed renders.

---

## License

Helios Engine is licensed under the **Elastic License 2.0 (ELv2)**. This license is designed to encourage widespread adoption while protecting our ability to build a SaaS platform.

### What This Means

**You Can:**
- ‚úÖ **Build commercial products** - Use Helios Engine in any commercial application or product
- ‚úÖ **Embed in applications** - Include Helios Engine in your software, whether open source or proprietary
- ‚úÖ **Modify and distribute** - Fork, modify, and distribute Helios Engine
- ‚úÖ **Create video platforms** - Build video creation tools, editors, or platforms using Helios Engine
- ‚úÖ **Use internally** - Use Helios Engine for internal business purposes without restrictions
- ‚úÖ **Sell products** - Sell products that use or include Helios Engine
- ‚úÖ **Contribute** - Contribute improvements back to the open source project

**You Cannot:**
- ‚ùå **Offer Helios as a managed service** - You cannot provide Helios Engine as a hosted/managed service (SaaS) to third parties
- ‚ùå **Resell Helios infrastructure** - You cannot offer Helios Engine rendering infrastructure as a service

**What This Means in Practice:**

This license is **perfect for founders building video platforms**. You can:
- Build a video editing SaaS platform using Helios Engine ‚úÖ
- Create a video generation tool for your customers ‚úÖ
- Build a white-label video creation platform ‚úÖ
- Embed Helios Engine in your application ‚úÖ
- Sell products that use Helios Engine ‚úÖ

You just can't offer Helios Engine itself as a managed/hosted service to others.

### Why Elastic License 2.0?

We chose Elastic License 2.0 because:
- **Encourages adoption** - Developers can build commercial products without restrictions
- **Protects SaaS opportunity** - Prevents competitors from offering Helios as a managed service
- **Well-established** - Used by Elasticsearch, Kibana, and other successful projects
- **Clear boundaries** - Simple rule: build products ‚úÖ, offer managed services ‚ùå
- **Founder-friendly** - Perfect for founders building video platforms (our target customers!)

This license allows us to build a SaaS platform around Helios while enabling a thriving ecosystem of products built on top of it.

### Commercial Licensing

If you need to offer Helios Engine as a managed service or have questions about commercial licensing, please [contact us](mailto:me@gavinbintz.com).

See [LICENSE](LICENSE) for full text.

---

## Services & Commercial Offerings

Helios Engine is free and open source, allowing you to build video creation applications without restrictions. To support ongoing development and provide managed infrastructure, we plan to offer the following commercial services in the future:

### Helios API (API as a Service) üöÄ *Primary Service*

**Programmatic video rendering without managing infrastructure.**

Render videos programmatically via REST API. Ideal for developers who want to integrate video creation into their applications without managing rendering infrastructure, GPU acceleration, or distributed rendering systems.

**Planned Features:**
- **REST API** - Simple HTTP endpoints for video rendering
- **Webhook notifications** - Get notified when renders complete
- **Queue management** - Priority queues, batch rendering, job status tracking
- **Distributed rendering** - Leverage our infrastructure for fast, scalable rendering
- **Multiple formats** - MP4, WebM, GIF, and more
- **Custom resolutions** - Render at any resolution up to 4K
- **SDKs** - Official SDKs for popular languages (JavaScript, Python, etc.)

**Use Cases:**
- Integrate video generation into your SaaS platform
- Build automated video workflows
- Generate personalized videos at scale
- Create video content from templates and data
- Add video creation capabilities to existing applications

**Pricing Model (Planned):**
- **Pay-as-you-go** - Per-minute rendering costs
- **Render credits** - Bulk purchases with discounts
- **Free tier** - Limited renders per month for testing and development
- **Enterprise plans** - Custom pricing with SLA guarantees, dedicated infrastructure

This service is designed for developers and teams who want the power of Helios Engine without the complexity of managing rendering infrastructure. Perfect for founders building video platforms who need reliable, scalable rendering infrastructure.

### Helios Cloud (Managed Platform)

**A hosted video creation platform powered by Helios Engine.**

A full-featured SaaS platform for creating, editing, and managing videos. Built on Helios Engine, providing a user-friendly interface for non-technical users while leveraging the performance of the underlying engine.

**Planned Features:**
- Web-based video editor
- Integrations with data sources (e.g. databases, APIs)
- Template library with pre-built templates for common use cases
- Collaboration tools for teams
- Asset management (images, videos, audio, fonts)
- Analytics and insights

**Target Users:**
- Content creators
- Marketing teams
- Agencies
- Non-technical users who want video creation capabilities

### Enterprise Services

**For organizations with advanced requirements:**

- **Enterprise Support** - SLA-backed support, dedicated account management, priority assistance
- **Professional Services** - Custom implementations, integrations, architecture consulting
- **On-Premise Deployments** - Self-hosted Helios Engine for organizations with security/compliance requirements
- **Commercial Licensing** - For companies that want to offer Helios Engine as a managed service to their customers
- **Training & Certification** - Developer training, best practices workshops, official certification programs

### Marketplace & Ecosystem

**A marketplace for Helios extensions and assets:**

- **Template Marketplace** - Video templates created by the community
- **Plugin System** - Extensions and integrations for Helios Engine
- **Asset Marketplace** - Stock footage, music, graphics optimized for Helios
- **Integration Marketplace** - Pre-built integrations with popular tools and platforms

### Our Business Model

**Free engine, paid infrastructure and services.**

Similar to successful open-source companies like MongoDB (Atlas), Elastic (Elastic Cloud), and GitLab (GitLab.com), we believe in:

- **Open source core** - Helios Engine remains free and open source forever
- **Managed services** - Pay for convenience, scale, and support
- **Ecosystem growth** - Marketplace and community-driven extensions

This model ensures:
- ‚úÖ Unlimited adoption of Helios Engine (no licensing barriers)
- ‚úÖ Sustainable business to support long-term development
- ‚úÖ Thriving ecosystem of products built on Helios
- ‚úÖ Multiple options for users (self-hosted or managed services)

**For developers:** Use Helios Engine for free. Build your applications, deploy your own infrastructure, and scale as needed.

**For teams that want managed infrastructure:** Use Helios API or Helios Cloud to offload infrastructure management and focus on building your product.

We're committed to keeping Helios Engine open source and free, while building sustainable commercial services that add value for teams that need managed infrastructure and support.

---

## Contributing

We welcome contributions! This project is primarily developed by an autonomous AI agent fleet, but human contributions are valued.

- **Bug reports**: Open an issue
- **Feature requests**: Open an issue or PR
- **Code contributions**: Fork, branch, PR

---

<div align="center">

**‚òÄÔ∏è Video is light over time.**

[Documentation](./docs/) ‚Ä¢ [Examples](./examples/) ‚Ä¢ [Backlog](./docs/BACKLOG.md) ‚Ä¢ [Progress](./docs/PROGRESS.md)

*Built with AI agents by [Gavin Bintz](https://github.com/BintzGavin)*

</div>
