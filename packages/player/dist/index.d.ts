import { HeliosSchema, DiagnosticReport } from "@helios-project/core";
import type { HeliosController } from "./controllers";
import { ClientSideExporter } from "./features/exporter";
import { HeliosTextTrack, HeliosTextTrackList, TrackHost } from "./features/text-tracks";
import { HeliosAudioTrack, HeliosAudioTrackList, AudioTrackHost } from "./features/audio-tracks";
export { ClientSideExporter };
export type { HeliosController };
interface MediaError {
    readonly code: number;
    readonly message: string;
    readonly MEDIA_ERR_ABORTED: number;
    readonly MEDIA_ERR_NETWORK: number;
    readonly MEDIA_ERR_DECODE: number;
    readonly MEDIA_ERR_SRC_NOT_SUPPORTED: number;
}
export declare class HeliosPlayer extends HTMLElement implements TrackHost, AudioTrackHost {
    private iframe;
    private pipVideo;
    private _textTracks;
    private _audioTracks;
    private _domTracks;
    private playPauseBtn;
    private volumeBtn;
    private volumeSlider;
    private scrubber;
    private scrubberWrapper;
    private scrubberTooltip;
    private markersContainer;
    private timeDisplay;
    private exportBtn;
    private overlay;
    private statusText;
    private retryBtn;
    private retryAction;
    private speedSelector;
    private fullscreenBtn;
    private pipBtn;
    private captionsContainer;
    private ccBtn;
    private showCaptions;
    private lastCaptionsHash;
    private debugOverlay;
    private debugContent;
    private closeDebugBtn;
    private copyDebugBtn;
    private clickLayer;
    private posterContainer;
    private posterImage;
    private bigPlayBtn;
    private pendingSrc;
    private isLoaded;
    private resizeObserver;
    private controller;
    private mediaSession;
    private directHelios;
    private unsubscribe;
    private connectionInterval;
    private abortController;
    private isExporting;
    private isScrubbing;
    private wasPlayingBeforeScrub;
    private lastState;
    private pendingProps;
    private _error;
    private _pendingVolume;
    private _pendingPlaybackRate;
    private _pendingMuted;
    static readonly HAVE_NOTHING = 0;
    static readonly HAVE_METADATA = 1;
    static readonly HAVE_CURRENT_DATA = 2;
    static readonly HAVE_FUTURE_DATA = 3;
    static readonly HAVE_ENOUGH_DATA = 4;
    static readonly NETWORK_EMPTY = 0;
    static readonly NETWORK_IDLE = 1;
    static readonly NETWORK_LOADING = 2;
    static readonly NETWORK_NO_SOURCE = 3;
    private _readyState;
    private _networkState;
    get readyState(): number;
    get networkState(): number;
    get error(): MediaError | null;
    get currentSrc(): string;
    canPlayType(type: string): CanPlayTypeResult;
    get defaultMuted(): boolean;
    set defaultMuted(val: boolean);
    private _defaultPlaybackRate;
    get defaultPlaybackRate(): number;
    set defaultPlaybackRate(val: number);
    private _preservesPitch;
    get preservesPitch(): boolean;
    set preservesPitch(val: boolean);
    get srcObject(): MediaProvider | null;
    set srcObject(val: MediaProvider | null);
    get crossOrigin(): string | null;
    set crossOrigin(val: string | null);
    get seeking(): boolean;
    get buffered(): TimeRanges;
    get seekable(): TimeRanges;
    get played(): TimeRanges;
    get videoWidth(): number;
    get videoHeight(): number;
    get currentTime(): number;
    set currentTime(val: number);
    get currentFrame(): number;
    set currentFrame(val: number);
    get duration(): number;
    get paused(): boolean;
    get ended(): boolean;
    get volume(): number;
    set volume(val: number);
    get muted(): boolean;
    set muted(val: boolean);
    get interactive(): boolean;
    set interactive(val: boolean);
    get playbackRate(): number;
    set playbackRate(val: number);
    get fps(): number;
    get src(): string;
    set src(val: string);
    get autoplay(): boolean;
    set autoplay(val: boolean);
    get loop(): boolean;
    set loop(val: boolean);
    get controls(): boolean;
    set controls(val: boolean);
    get poster(): string;
    set poster(val: string);
    get preload(): string;
    set preload(val: string);
    get sandbox(): string;
    set sandbox(val: string);
    get disablePictureInPicture(): boolean;
    set disablePictureInPicture(val: boolean);
    requestPictureInPicture(): Promise<PictureInPictureWindow>;
    private togglePip;
    private onEnterPip;
    private onLeavePip;
    play(): Promise<void>;
    load(): void;
    pause(): void;
    static get observedAttributes(): string[];
    constructor();
    get textTracks(): HeliosTextTrackList;
    get audioTracks(): HeliosAudioTrackList;
    addTextTrack(kind: string, label?: string, language?: string): HeliosTextTrack;
    handleAudioTrackEnabledChange(track: HeliosAudioTrack): void;
    handleTrackModeChange(track: HeliosTextTrack): void;
    attributeChangedCallback(name: string, oldVal: string, newVal: string): void;
    private updateControlsVisibility;
    private updateCCButtonVisibility;
    get inputProps(): Record<string, any> | null;
    set inputProps(val: Record<string, any> | null);
    connectedCallback(): void;
    disconnectedCallback(): void;
    private loadIframe;
    private handleBigPlayClick;
    private updatePosterVisibility;
    private setControlsDisabled;
    private lockPlaybackControls;
    private handleIframeLoad;
    private startConnectionAttempts;
    private stopConnectionAttempts;
    private handleWindowMessage;
    private handleSlotChange;
    private setController;
    private updateAspectRatio;
    private togglePlayPause;
    private toggleMute;
    private handleVolumeInput;
    private handleScrubberInput;
    private handleScrubStart;
    private handleScrubEnd;
    private handleScrubberHover;
    private handleScrubberLeave;
    private handleSpeedChange;
    private toggleCaptions;
    private toggleDiagnostics;
    private handleCopyDebug;
    private handleKeydown;
    private seekRelative;
    private toggleFullscreen;
    private updateFullscreenUI;
    private updateUI;
    private showStatus;
    private hideStatus;
    getController(): HeliosController | null;
    getSchema(): Promise<HeliosSchema | undefined>;
    diagnose(): Promise<DiagnosticReport>;
    private retryConnection;
    private renderClientSide;
}
